/**
 * Export Meta-Tool
 *
 * Exports records to CSV, JSON, Markdown, or download script format.
 * Can write to file or return content directly.
 */

import { writeFile } from 'node:fs/promises';
import type { SourceTool } from '../base-source.js';
import { successResponse, errorResponse } from '../types.js';

type ExportFormat = 'csv' | 'json' | 'markdown' | 'download-script';

const FORMATS: ExportFormat[] = ['csv', 'json', 'markdown', 'download-script'];

/**
 * Escape CSV value (handle commas, quotes, newlines)
 */
function escapeCsvValue(value: unknown): string {
  if (value === null || value === undefined) return '';
  const str = String(value);
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

/**
 * Convert records to CSV format
 */
function toCsv(records: Record<string, unknown>[], fields?: string[]): string {
  if (records.length === 0) return '';

  // Determine fields to use
  const headers = fields ?? Object.keys(records[0]);

  // Create header row
  const headerRow = headers.map(escapeCsvValue).join(',');

  // Create data rows
  const dataRows = records.map((record) =>
    headers.map((field) => escapeCsvValue(record[field])).join(',')
  );

  return [headerRow, ...dataRows].join('\n');
}

/**
 * Convert records to Markdown table format
 */
function toMarkdown(records: Record<string, unknown>[], fields?: string[]): string {
  if (records.length === 0) return '*No records*';

  // Determine fields to use
  const headers = fields ?? Object.keys(records[0]);

  // Create header row
  const headerRow = `| ${headers.join(' | ')} |`;

  // Create separator row
  const separatorRow = `| ${headers.map(() => '---').join(' | ')} |`;

  // Create data rows
  const dataRows = records.map((record) => {
    const values = headers.map((field) => {
      const value = record[field];
      if (value === null || value === undefined) return '';
      // Escape pipe characters and truncate long values
      return String(value).replace(/\|/g, '\\|').substring(0, 100);
    });
    return `| ${values.join(' | ')} |`;
  });

  return [headerRow, separatorRow, ...dataRows].join('\n');
}

/**
 * Generate download script (curl/wget commands) for URLs in records
 */
function toDownloadScript(records: Record<string, unknown>[]): string {
  const lines: string[] = ['#!/bin/bash', '', '# Download script generated by australian-history-mcp', ''];

  // Find URL fields in records
  const urlFields = ['url', 'imageUrl', 'thumbnailUrl', 'manifestUrl', 'downloadUrl', 'previewUrl', 'tifUrl'];

  let count = 0;
  for (const record of records) {
    for (const field of urlFields) {
      const url = record[field];
      if (typeof url === 'string' && url.startsWith('http')) {
        // Extract filename from URL or use index
        const filename = url.split('/').pop()?.split('?')[0] || `file_${count}`;
        lines.push(`curl -O "${url}" # ${filename}`);
        count++;
      }
    }
  }

  if (count === 0) {
    lines.push('# No downloadable URLs found in records');
    lines.push('# URL fields checked: ' + urlFields.join(', '));
  } else {
    lines.push('', `# Total files: ${count}`);
  }

  return lines.join('\n');
}

export const exportMetaTool: SourceTool = {
  schema: {
    name: 'export',
    description: 'Export records to CSV, JSON, Markdown, or download script.',
    inputSchema: {
      type: 'object' as const,
      properties: {
        records: {
          type: 'array',
          description: 'Records to export (from search/harvest results)',
          items: { type: 'object' },
        },
        format: {
          type: 'string',
          description: 'Export format',
          enum: FORMATS,
        },
        path: {
          type: 'string',
          description: 'Output file path (optional, returns content if omitted)',
        },
        fields: {
          type: 'array',
          description: 'Fields to include (optional, all fields if omitted)',
          items: { type: 'string' },
        },
      },
      required: ['records', 'format'],
    },
  },

  async execute(args: Record<string, unknown>) {
    const input = args as {
      records: Record<string, unknown>[];
      format: ExportFormat;
      path?: string;
      fields?: string[];
    };

    if (!input.records || !Array.isArray(input.records)) {
      return errorResponse('Records array is required', 'export');
    }

    if (!input.format || !FORMATS.includes(input.format)) {
      return errorResponse(`Invalid format. Choose from: ${FORMATS.join(', ')}`, 'export');
    }

    try {
      let content: string;

      switch (input.format) {
        case 'csv':
          content = toCsv(input.records, input.fields);
          break;
        case 'json':
          content = JSON.stringify(input.records, null, 2);
          break;
        case 'markdown':
          content = toMarkdown(input.records, input.fields);
          break;
        case 'download-script':
          content = toDownloadScript(input.records);
          break;
      }

      // Write to file if path provided
      if (input.path) {
        await writeFile(input.path, content, 'utf-8');
        return successResponse({
          status: 'saved',
          path: input.path,
          format: input.format,
          recordCount: input.records.length,
          bytes: Buffer.byteLength(content, 'utf-8'),
        });
      }

      // Return content directly
      return successResponse({
        status: 'generated',
        format: input.format,
        recordCount: input.records.length,
        content,
      });
    } catch (error) {
      return errorResponse(error, 'export');
    }
  },
};
